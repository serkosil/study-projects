-- Самостоятельный проект - 2 "Продвинутый SQL"

-- В базе хранятся данные о постах в сервисе StackOverflow за 2008 год, но в таблицах есть информация и о более поздних оценках, которые эти посты получили. 

-- Описание данных

-- Таблица stackoverflow.badges хранит информацию о значках, которые присуждаются за разные достижения. Например, пользователь, правильно ответивший на большое количество вопросов про PostgreSQL, может получить значок postgresql:
-- id - идентификатор значка, первичный ключ таблицы;
-- name - название значка;
-- user_id - идентификатор пользователя, которому присвоили значок, внешний ключ, отсылающий к таблице users;
-- creation_date - дата присвоения значка.

-- Таблица stackoverflow.post_types содержит информацию о типе постов. Их может быть два: Question — пост с вопросом; Answer — пост с ответом:
-- id - идентификатор поста, первичный ключ таблицы;
-- type - тип поста;

-- Таблица stackoverflow.posts содержит информацию о постах:
-- id - идентификатор поста, первичный ключ таблицы;
-- title - заголовок поста;
-- creation_date - дата создания поста;
-- favorites_count - число, которое показывает, сколько раз пост добавили в «Закладки»;
-- last_activity_date - дата последнего действия в посте, например комментария;
-- last_edit_date - дата последнего изменения поста;
-- user_id - идентификатор пользователя, который создал пост, внешний ключ к таблице users;
-- parent_id - если пост написали в ответ на другую публикацию, в это поле попадёт идентификатор поста с вопросом;
-- post_type_id - идентификатор типа поста, внешний ключ к таблице post_types;
-- score - количество очков, которое набрал пост;
-- views_count - количество просмотров.

-- Таблица stackoverflow.users содержит информацию о пользователях:
-- id - идентификатор пользователя, первичный ключ таблицы;
-- creation_date - дата регистрации пользователя;
-- display_name - имя пользователя;
-- last_access_date - дата последнего входа;
-- location - местоположение;
-- reputation - очки репутации, которые получают за хорошие вопросы и полезные ответы;
-- views - число просмотров профиля пользователя.

-- Таблица stackoverflow.vote_types содержит информацию о типах голосов. Голос — это метка, которую пользователи ставят посту. Типов бывает несколько: UpMod — такую отметку получают посты с вопросами или ответами, которые пользователи посчитали уместными и полезными; DownMod — такую отметку получают посты, которые показались пользователям наименее полезными; Close — такую метку ставят опытные пользователи сервиса, если заданный вопрос нужно доработать или он вообще не подходит для платформы; Offensive — такую метку могут поставить, если пользователь ответил на вопрос в грубой и оскорбительной манере, например, указав на неопытность автора поста; Spam — такую метку ставят в случае, если пост пользователя выглядит откровенной рекламой:
-- id - идентификатор типа голоса, первичный ключ;
-- name - название метки.

-- Таблица stackoverflow.votes содержит информацию о голосах за посты:
-- id - идентификатор голоса, первичный ключ;
-- post_id - идентификатор поста, внешний ключ к таблице posts;
-- user_id - идентификатор пользователя, который поставил посту голос, внешний ключ к таблице users;
-- bounty_amount - сумма вознаграждения, которое назначают, чтобы привлечь внимание к посту;
-- vote_type_id - идентификатор типа голоса, внешний ключ к таблице vote_types;
-- creation_date - дата назначения голоса.

-- Задания (Первая часть)
-- Задача 1. Найдите количество вопросов, которые набрали больше 300 очков или как минимум 100 раз были добавлены в «Закладки». Чтобы отфильтровать данные, используйте логические операторы AND и OR. Обратите внимание на приоритет выполнения этих операторов.

SELECT COUNT(id)
FROM stackoverflow.posts
WHERE (score>300
       OR favorites_count >=100)
  AND post_type_id = 1

-- Задача 2. Сколько в среднем в день задавали вопросов с 1 по 18 ноября 2008 включительно? Результат округлите до целого числа. Делая срез, обратите внимание на тип данных поля c датой поста. Сгруппируйте записи по дням и найдите количество вопросов в день, а после посчитайте среднее.

WITH cnt AS
  (SELECT CAST(DATE_TRUNC('day', p.creation_date) AS date) AS date,
          COUNT(p.id)
   FROM stackoverflow.posts p
   WHERE post_type_id = 1
   GROUP BY CAST(DATE_TRUNC('day', p.creation_date) AS date)
   HAVING CAST(DATE_TRUNC('day', p.creation_date) AS date) BETWEEN '2008-11-01' AND '2008-11-18')
SELECT ROUND(AVG(COUNT))
FROM cnt

-- Задача 3. Сколько пользователей получили значки сразу в день регистрации? Выведите количество уникальных пользователей. Данные о пользователях хранит таблица users, а данные о значках — таблица badges. Соедините их.

SELECT COUNT(DISTINCT(u.id))
FROM stackoverflow.users u
JOIN stackoverflow.badges b ON u.id = b.user_id
WHERE CAST(DATE_TRUNC('day', u.creation_date) AS date) = CAST(DATE_TRUNC('day', b.creation_date) AS date)

-- Задача 4. Сколько уникальных постов пользователя с именем Joel Coehoorn получили хотя бы один голос? Присоедините несколько таблиц, чтобы собрать все нужные данные.

SELECT COUNT(DISTINCT(p.id))
FROM stackoverflow.posts p
JOIN stackoverflow.users u ON p.user_id = u.id
RIGHT JOIN stackoverflow.votes v ON p.id = v.post_id
WHERE u.display_name LIKE 'Joel Coehoorn'

-- Задача 5. Выгрузите все поля таблицы vote_types. Добавьте к таблице поле rank, в которое войдут номера записей в обратном порядке. Таблица должна быть отсортирована по полю id. Чтобы пронумеровать записи в обратном порядке, используйте оконную функцию.

SELECT *,
       RANK() OVER (
                    ORDER BY id DESC) AS rank
FROM stackoverflow.vote_types
ORDER BY id

-- Задача 6. Отберите 10 пользователей, которые поставили больше всего голосов типа Close. Отобразите таблицу из двух полей: идентификатором пользователя и количеством голосов. Отсортируйте данные сначала по убыванию количества голосов, потом по убыванию значения идентификатора пользователя. Таблицы vote_types и users не связаны напрямую, поэтому вам понадобится присоединить несколько таблиц. Не забудьте добавить условие.

SELECT v.user_id,
       COUNT(v.id)
FROM stackoverflow.votes v
WHERE vote_type_id = 6
GROUP BY v.user_id
ORDER BY COUNT(v.id) DESC, v.user_id DESC
LIMIT 10

-- Задача 7. Отберите 10 пользователей по количеству значков, полученных в период с 15 ноября по 15 декабря 2008 года включительно. Отобразите несколько полей: идентификатор пользователя; число значков; место в рейтинге — чем больше значков, тем выше рейтинг. Пользователям, которые набрали одинаковое количество значков, присвойте одно и то же место в рейтинге. Отсортируйте записи по количеству значков по убыванию, а затем по возрастанию значения идентификатора пользователя. Чтобы назначить места в рейтинге, воспользуйтесь оконной функцией ранжирования.

SELECT b.user_id,
       COUNT(b.id),
       DENSE_RANK() OVER (
                          ORDER BY COUNT(b.id) DESC)
FROM stackoverflow.badges b
WHERE CAST(creation_date AS date) BETWEEN '2008-11-15' AND '2008-12-15'
GROUP BY b.user_id
ORDER BY COUNT(b.id) DESC, b.user_id
LIMIT 10

-- Задача 8. Сколько в среднем очков получает пост каждого пользователя? Сформируйте таблицу из следующих полей: заголовок поста; идентификатор пользователя; число очков поста; среднее число очков пользователя за пост, округлённое до целого числа. Не учитывайте посты без заголовка, а также те, что набрали ноль очков. Используйте оконную функцию и укажите поле, по которому сформировать окна.

SELECT p.title,
       p.user_id,
       p.score,
       ROUND(AVG(p.score) OVER (PARTITION BY p.user_id))
FROM stackoverflow.posts p
WHERE p.score <> 0
  AND p.title IS NOT NULL

-- Задача 9. Отобразите заголовки постов, которые были написаны пользователями, получившими более 1000 значков. Посты без заголовков не должны попасть в список. Это задание лучше выполнить по частям. Сформируйте список пользователей, которые заработали больше 1000 значков. С помощью этого списка можно отфильтровать записи в основном запросе.

SELECT p.title
FROM stackoverflow.posts p
WHERE p.user_id IN
    (SELECT user_id
     FROM stackoverflow.badges
     GROUP BY user_id
     HAVING COUNT(id)>1000)
  AND p.title IS NOT NULL

-- Задача 10. Напишите запрос, который выгрузит данные о пользователях из Канады (англ. Canada). Разделите пользователей на три группы в зависимости от количества просмотров их профилей: пользователям с числом просмотров больше либо равным 350 присвойте группу 1; пользователям с числом просмотров меньше 350, но больше либо равно 100 — группу 2; пользователям с числом просмотров меньше 100 — группу 3. Отобразите в итоговой таблице идентификатор пользователя, количество просмотров профиля и группу. Пользователи с количеством просмотров меньше либо равным нулю не должны войти в итоговую таблицу. Чтобы создать категории пользователей, используйте оператор CASE. Отфильтруйте данные по стране, пользуясь оператором LIKE. Данные неидеальны: перед словом для поиска и после него могут встречаться лишние пробелы.

SELECT id,
       VIEWS,
       CASE
           WHEN VIEWS <100 THEN 3
           WHEN VIEWS <350 THEN 2
           WHEN VIEWS>=350 THEN 1
       END
FROM stackoverflow.users
WHERE LOCATION LIKE '%Canada%'
  AND VIEWS > 0

-- Задача 11. Дополните предыдущий запрос. Отобразите лидеров каждой группы — пользователей, которые набрали максимальное число просмотров в своей группе. Выведите поля с идентификатором пользователя, группой и количеством просмотров. Отсортируйте таблицу по убыванию просмотров, а затем по возрастанию значения идентификатора. Добавьте предыдущий запрос в подзапрос. Посчитайте максимальное количество просмотров по категориям. В список должны попасть пользователи, у которых число просмотров равно максимальному значению.

WITH us_users AS
  (SELECT id AS user_id,
          VIEWS AS views_cnt,
                   CASE
                       WHEN VIEWS <100 THEN 3
                       WHEN VIEWS <350 THEN 2
                       WHEN VIEWS>=350 THEN 1
                   END AS groups
   FROM stackoverflow.users
   WHERE LOCATION LIKE '%Canada%'
     AND VIEWS > 0)
SELECT user_id,
       groups,
       views_cnt
FROM
  (SELECT user_id,
          views_cnt,
          groups,
          MAX(views_cnt) OVER (PARTITION BY groups
                               ORDER BY views_cnt DESC) AS max_views
   FROM us_users) AS max_us
WHERE views_cnt = max_views
ORDER BY views_cnt DESC,
         user_id;

-- Задача 12. Посчитайте ежедневный прирост новых пользователей в ноябре 2008 года. Сформируйте таблицу с полями: номер дня; число пользователей, зарегистрированных в этот день; сумму пользователей с накоплением. Для подсчёта суммы с накоплением вам понадобится оконная функция. Не забудьте отфильтровать таблицу по месяцу и году.

WITH t1 AS
  (SELECT CAST(DATE_TRUNC('day', creation_date) AS date) AS days,
          COUNT(id) AS users_cnt
   FROM stackoverflow.users
   GROUP BY CAST(DATE_TRUNC('day', creation_date) AS date)
   ORDER BY CAST(DATE_TRUNC('day', creation_date) AS date))
SELECT RANK() OVER (
                    ORDER BY days), users_cnt,
                                    SUM(users_cnt) OVER (
                                                         ORDER BY days)::int AS cum
FROM t1
WHERE CAST(DATE_TRUNC('day', days) AS date) BETWEEN '2008-11-01' AND '2008-11-30';

-- Задача 13. Для каждого пользователя, который написал хотя бы один пост, найдите интервал между регистрацией и временем создания первого поста. Отобразите: идентификатор пользователя; разницу во времени между регистрацией и первым постом. Для каждого пользователя найдите время создания первого поста с помощью оконной функции ранжирования. Если от этого времени отнять дату регистрации пользователя, получится нужный интервал. Не меняйте тип данных поля creation_date.

WITH p AS
  (SELECT user_id,
          creation_date,
          RANK() OVER (PARTITION BY user_id
                       ORDER BY creation_date) AS first_pub
   FROM stackoverflow.posts
   ORDER BY user_id)
SELECT user_id,
       p.creation_date - u.creation_date AS delta
FROM p
JOIN stackoverflow.users AS u ON p.user_id = u.id
WHERE first_pub = 1;

-- Задания (Вторая часть)
-- Задача 1. Выведите общую сумму просмотров у постов, опубликованных в каждый месяц 2008 года. Если данных за какой-либо месяц в базе нет, такой месяц можно пропустить. Результат отсортируйте по убыванию общего количества просмотров. Используйте функцию для усечения даты, а затем сгруппируйте и отсортируйте данные.

SELECT DATE_TRUNC('month', creation_date)::date AS month_date,
       SUM(views_count) AS total_views
FROM stackoverflow.posts
WHERE EXTRACT(YEAR
              FROM creation_date) = 2008
GROUP BY DATE_TRUNC('month', creation_date)
ORDER BY SUM(views_count) DESC;

--Данные отличаются. Возможно, повышенная активность в сентябре и октябре связана с началом учебного года. Малая активность в июле может свидетельствовать о неполноте данных.

-- Задача 2. Выведите имена самых активных пользователей, которые в первый месяц после регистрации (включая день регистрации) дали больше 100 ответов. Вопросы, которые задавали пользователи, не учитывайте. Для каждого имени пользователя выведите количество уникальных значений user_id. Отсортируйте результат по полю с именами в лексикографическом порядке. Вам нужно присоединить несколько таблиц — изучите внимательнее описание базы. Чтобы добавить промежуток времени к дате, используйте ключевое слово INTERVAL, например, так: <дата> + INTERVAL '1 year 2 months 3 days'.

SELECT u.display_name,
       COUNT(DISTINCT p.user_id)
FROM stackoverflow.posts AS p
JOIN stackoverflow.users AS u ON p.user_id=u.id
JOIN stackoverflow.post_types AS pt ON pt.id=p.post_type_id
WHERE p.creation_date::date BETWEEN u.creation_date::date AND (u.creation_date::date + INTERVAL '1 month')
  AND pt.type LIKE 'Answer'
GROUP BY u.display_name
HAVING COUNT(p.id) > 100
ORDER BY u.display_name;

-- Одному имени пользователя должен соответствовать один user_id. Но это не так: многим популярным именам вроде Alan, Dan или Chris соответствует несколько значений user_id. Данные лучше не анализировать по имени, иначе результаты будут некорректными.

-- Задача 3. Выведите количество постов за 2008 год по месяцам. Отберите посты от пользователей, которые зарегистрировались в сентябре 2008 года и сделали хотя бы один пост в декабре того же года. Отсортируйте таблицу по значению месяца по убыванию. Сначала найдите идентификаторы пользователей, которые зарегистрировались в сентябре 2008 года и оставили хотя бы один пост в декабре. Затем используйте результат для среза и посчитайте посты по месяцам.

WITH users AS
  (SELECT u.id
   FROM stackoverflow.posts AS p
   JOIN stackoverflow.users AS u ON p.user_id=u.id
   WHERE (u.creation_date::date BETWEEN '2008-09-01' AND '2008-09-30')
     AND (p.creation_date::date BETWEEN '2008-12-01' AND '2008-12-31')
   GROUP BY u.id)
SELECT DATE_TRUNC('month', p.creation_date)::date AS MONTH,
       COUNT(p.id)
FROM stackoverflow.posts AS p
WHERE p.user_id IN
    (SELECT *
     FROM users)
  AND DATE_TRUNC('year', p.creation_date)::date = '2008-01-01'
GROUP BY DATE_TRUNC('month', p.creation_date)::date
ORDER BY DATE_TRUNC('month', p.creation_date)::date DESC;

-- В итоговой таблице встречаются аномальные значения: пользователи, зарегистрированные в сентябре, были активны и в августе. Возможно, это ошибка в данных.

-- Задача 4. Используя данные о постах, выведите несколько полей: идентификатор пользователя, который написал пост; дата создания поста; количество просмотров у текущего поста; сумма просмотров постов автора с накоплением. Данные в таблице должны быть отсортированы по возрастанию идентификаторов пользователей, а данные об одном и том же пользователе — по возрастанию даты создания поста. Для подсчёта суммы с накоплением используйте оконную функцию.

SELECT user_id,
       creation_date,
       views_count,
       SUM (views_count) OVER (PARTITION BY user_id
                               ORDER BY creation_date) AS cumulative_count
FROM stackoverflow.posts
ORDER BY user_id,
         creation_date;

-- Задача 5. Сколько в среднем дней в период с 1 по 7 декабря 2008 года включительно пользователи взаимодействовали с платформой? Для каждого пользователя отберите дни, в которые он или она опубликовали хотя бы один пост. Нужно получить одно целое число — не забудьте округлить результат. Посчитайте, сколько активных дней было у каждого пользователя. Добавьте данные в общее табличное выражение и используйте в основном запросе.

WITH TEMP AS
  (SELECT user_id,
          COUNT(DISTINCT DATE_TRUNC('day', creation_date)::date)
   FROM stackoverflow.posts
   WHERE creation_date::date BETWEEN '2008-12-01' AND '2008-12-07'
   GROUP BY user_id)
SELECT ROUND(AVG(COUNT))::int AS RESULT
FROM TEMP;

-- Задача 6. На сколько процентов менялось количество постов ежемесячно с 1 сентября по 31 декабря 2008 года? Отобразите таблицу со следующими полями: номер месяца; количество постов за месяц; процент, который показывает, насколько изменилось количество постов в текущем месяце по сравнению с предыдущим. Если постов стало меньше, значение процента должно быть отрицательным, если больше — положительным. Округлите значение процента до двух знаков после запятой. Напомним, что при делении одного целого числа на другое в PostgreSQL в результате получится целое число, округлённое до ближайшего целого вниз. Чтобы этого избежать, переведите делимое в тип numeric. Эту задачу стоит декомпозировать. Сформируйте запрос, который отобразит номер месяца и количество постов. Затем можно использовать оконную функцию, которая вернёт значение за предыдущий месяц, и посчитать процент. Не забудьте сравнить количество постов в сентябре со значением предыдущего месяца. Вы получите NULL — это нормально.

WITH TEMP AS
  (SELECT EXTRACT(MONTH
                  FROM creation_date)::int AS creation_month,
          COUNT(id) AS posts_count
   FROM stackoverflow.posts
   WHERE EXTRACT(MONTH
                 FROM creation_date)::int BETWEEN 9 AND 12
   GROUP BY creation_month)
SELECT *,
       ROUND((posts_count::numeric/LAG(posts_count) OVER()-1)*100, 2)
FROM TEMP;

-- Задача 7. Найдите пользователя, который опубликовал больше всего постов за всё время с момента регистрации. Выведите данные его активности за октябрь 2008 года в таком виде: номер недели; дата и время последнего поста, опубликованного на этой неделе. Декомпозируйте задачу: найдите пользователя, который опубликовал больше всего постов; найдите дату и время создания каждого поста этого пользователя и номер недели; отобразите данные только о последних постах пользователя. Для этого можно использовать оконную функцию.

WITH active_user AS
  (SELECT user_id,
          COUNT(id)
   FROM stackoverflow.posts
   GROUP BY user_id
   ORDER BY COUNT(id) DESC
   LIMIT 1)
SELECT EXTRACT(WEEK
               FROM p.creation_date)::int AS week_creation,
       MAX(p.creation_date) AS creation_date
FROM active_user AS au
JOIN stackoverflow.posts AS p ON au.user_id=p.user_id
WHERE DATE_TRUNC('month', p.creation_date)::date = '2008-10-01'
GROUP BY week_creation;